“
Complete the two partial SystemVerilog RTL files:

- sources/axi_top.sv : an AXI4-Lite slave peripheral that exposes a small memory-mapped register space.
- sources/csr_regfile.sv : an internal register file implementing data registers + CSR registers with per-register access permissions.

Read the specifications placed in /workdir/docs/Specification.md to construct and properly integrate the modules.
The design must be synthesizable, parameterized, and robust to AXI-Lite backpressure.

Hints:

1) Do not make access_violation sticky.
   - access_violation must be 00 by default.
   - Only assert 01/10/11 in the cycle where reg_write or reg_read is asserted.
   - If you hold a previous violation, later valid writes can incorrectly return SLVERR.

2) CSR bank is fixed and must match permissions exactly.
   - NUM_CSR_REGS = 4
   - CSR offsets (relative to CSR base) and access are:
       0: mcycle  RO
       1: mstatus RW
       2: mcause  RO
       3: mip     RO
   - Write to mstatus must return OKAY (bresp=0).
   - Write to mcycle must return SLVERR (bresp=2) and must not modify storage.
   - Both mistakes happened across the two failed attempts.

3) Out-of-range must always return SLVERR.
   - Any index >= (NUM_DATA_REGS + NUM_CSR_REGS) is out of range.
   - Out-of-range write: bresp = 2
   - Out-of-range read:  rresp = 2 and rdata = 0
   - One attempt returned OKAY for out-of-range and failed immediately.

4) Data-reg permissions must be enforced through AXI responses.
   - Read from WO data reg must return SLVERR (rresp=2) and rdata=0.
   - Write to RO data reg must return SLVERR (bresp=2) and must not modify storage.

5) AXI-Lite ordering: do not require AW and W handshakes in the same cycle.
   - Capture awaddr on AW handshake.
   - Capture wdata/wstrb on W handshake.
   - Complete the write once both have occurred (one outstanding transaction at a time).
   - A failed attempt incorrectly assumed AW and W must arrive together, which breaks when channels are decoupled.

6) Timeout semantics depend on response acceptance (this is what the failing tests check).
   - The timeout counter must measure "transaction not accepted", not just "missing address/data".
   - Define write transaction complete only when the B handshake happens: bvalid && bready.
   - Define read transaction complete only when the R handshake happens: rvalid && rready.
   - Write timeout test case: awvalid=1, wvalid=1, but bready=0 for > TXN_TIMEOUT cycles.
       * After TXN_TIMEOUT cycles, you MUST be driving bvalid=1 and bresp=2 (SLVERR).
       * If you asserted bvalid earlier with bresp=0 (OKAY) while bready was 0, you must OVERRIDE/UPDATE bresp to 2 once timeout hits, and keep bvalid asserted until bready=1.
       * Do not clear/reset the write timeout counter just because bvalid is 1; keep counting until bready accepts (or until you force the timeout response).
   - Read timeout test case: arvalid=1, but rready=0 for > TXN_TIMEOUT cycles.
       * After TXN_TIMEOUT cycles, you MUST be driving rvalid=1, rresp=2 (SLVERR), and rdata=0.
       * If you asserted rvalid earlier with rresp=0 while rready was 0, you must OVERRIDE/UPDATE rresp to 2 once timeout hits, and keep rvalid asserted until rready=1.
       * Do not drop the response to recover; hold SLVERR response stable until accepted.

7) WSTRB byte enables must preserve non-strobed bytes.
   - Full write (all strobe bits 1): write wdata directly.
   - Partial write: read-modify-write (base merge on current register value), do not zero bytes where wstrb=0.

8) reg_rdata holding:
   - When reg_read is 0, do not drive reg_rdata to 0 every cycle. Keep it stable.
   - Do not gate a read using a previous-cycle access_violation; compute permissions from address and access map for the current operation.
”